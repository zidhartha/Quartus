module Register (
input clk , 
input EN , // enable write / read
input rst , 
input [4:0] selectW1 , // select for write
input [4:0] selectR1 , // select for reading
input [4:0] selectR2 , // select for reading
input read ,  // enabling read
input write , // // enabling write
input [31:0] addr , // input to store
output reg [31:0] outA , // output to read
output reg [31:0] outB   // output to read
);
reg [31:0] regfile [31:0];
integer i ;
always @ ( posedge clk or posedge rst ) begin
if ( rst == 1) begin
for ( i = 0; i < 32; i = i + 1) begin
regfile [ i ] = 32'b0 ;
end
end else if ( EN == 1) begin
case ({ read , write })
2'b01 : begin
if ( selectW1 != 0)
regfile [ selectW1 ] = addr ;
end
2'b10 : begin
outA = regfile [ selectR1 ];
outB = regfile [ selectR2 ];
end
2'b11 : begin
if ( selectW1 != 0)
regfile [ selectW1 ] = addr ;
outA = regfile [ selectR1 ];
outB = regfile [ selectR2 ];
end
endcase
end
end
endmodule 


//TestBench 

module Register_tb;
// Parameters
parameter CLK_PERIOD = 10;
// Signals
reg clk , EN , rst , read , write ;
reg [7:0] selectW1 , selectR1 , selectR2 ;
reg [31:0] addr ;
wire [31:0] outA , outB ;
// Instantiate the module
Register dut (
. clk ( clk ) ,
. EN ( EN ) ,
. rst ( rst ) ,
. selectW1 ( selectW1 ) ,
. selectR1 ( selectR1 ) ,
. selectR2 ( selectR2 ) ,
. read ( read ) ,
. write ( write ) ,
. addr ( addr ) ,
. outA ( outA ) ,
. outB ( outB )
);
// Clock generation
always begin
#5;
clk = 0;
#5
clk = 1;
end
// Test stimulus
initial begin
EN = 0;
rst = 1;
selectW1 = 0;
selectR1 = 0;
selectR2 = 0;
read = 0;
write = 0;
addr = 0;
#50 rst = 0;
// Test scenario 1: Write operation
#10;
EN = 1;
selectW1 = 1; // Select register to write to
addr = 123; // Data to write
write = 1;
#10;
write = 0;

#10;
// Test scenario 2: Read operation
selectR1 = 1;
selectR2 = 2;
read = 1;
#10;
read = 0;
#10;
// Test scenario 3: Write and Read operation
selectW1 = 3;
addr = 456;
write = 1;
#10;
write = 0;
#10;
selectR1 = 3;
selectR2 = 1;
read = 1;
#10;
read = 0;
#10;
// Test Scenario 4: when we want to write in 0 register
#10;
EN = 1;
selectW1 = 0;
addr = 123;
write = 1;
#10;
write = 0;
#10;
selectR1 = 0;
read = 1;
#10
read = 0;
end
endmodule 
